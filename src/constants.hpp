#pragma once

#include <string>

static std::string MAIN_FILE_CONTENT =
    "#include <iostream>\n"
    "#include <vector>\n"
    "\n"
    "int main(int args, char ** argv) {\n"
    "    std::vector<std::string> arguments;\n"
    "    arguments.reserve(args);\n"
    "    for(int i = 0; i< args; i++){\n"
    "      arguments.push_back(std::string(argv[i]));\n"
    "    }\n"
    "    std::cout << \"Hello with arguments:\\n\";\n"
    "    for(std::string argument : arguments){\n"
    "      std::cout << \" - \" << argument << \"\\n\";\n"
    "    }\n"
    "    std::cout << std::endl;\n"
    "    return 0;\n"
    "}\n";

static std::string TEST_EXAMPLE_FILE_CONTENT =
    "#include \"../lib/asap/t.hpp\"\n"
    "\n"
    "void test_example(T* t) {\n"
    "    t->assert(true);\n"
    "}\n"
    "\n"
    "int main() {\n"
    "    T t(\"ExampleSuite\");\n"
    "    t.test(\"SimpleAssert\", test_example);\n"
    "    return 0;\n"
    "}\n";

static std::string T_HEADER_FILE_CONTENT =
    ""
    "#ifndef _ASAP_T\n"
    "#define _ASAP_T\n"
    "\n"
    "#include \"stopwatch.hpp\"\n"
    "#include <functional>\n"
    "#include <iostream>\n"
    "#include <stdexcept>\n"
    "#include <string>\n"
    "\n"
    "class TestCaseFailure : public std::runtime_error {\n"
    "public:\n"
    "  TestCaseFailure(const std::string &message) : "
    "std::runtime_error(message) {}\n"
    "\n"
    "  const char *what() const noexcept override { return "
    "runtime_error::what(); }\n"
    "};\n"
    "\n"
    "class T {\n"
    "private:\n"
    "  const std::string ansi_fg_red = \"\x1b[31m\";\n"
    "  const std::string ansi_fg_green = \"\x1b[32m\";\n"
    "  const std::string ansi_reset = \"\x1b[0m\";\n"
    "  std::vector<std::string> failures_testnames;\n"
    "  std::vector<std::string> failures_messages;\n"
    "  std::vector<std::string> successes_testnames;\n"
    "  std::string suitname;\n"
    "\n"
    "public:\n"
    "  T(const std::string &suitname_param) {\n"
    "    failures_testnames = {};\n"
    "    failures_messages = {};\n"
    "    successes_testnames = {};\n"
    "    suitname = suitname_param;\n"
    "  };\n"
    "\n"
    "  void test(const std::string &testname,\n"
    "            const std::function<void(T *)> &testcase) {\n"
    "    StopWatch sw = StopWatch();\n"
    "    try {\n"
    "      testcase(this);\n"
    "    } catch (TestCaseFailure e) {\n"
    "      long duration_micro = sw.stop_micro();\n"
    "      std::cout << ansi_fg_red + \"FAILURE [\" + suitname + \"] of '\" + "
    "testname +\n"
    "                       \"': \" + e.what() + ansi_reset + \" (\" +\n"
    "                       std::to_string(duration_micro) + \"μs)\\n\";\n"
    "      return;\n"
    "    } catch (std::runtime_error e) {\n"
    "      long duration_micro = sw.stop_micro();\n"
    "      std::cout << ansi_fg_red + \"FAILURE [\" + suitname + \"] of '\" + "
    "testname +\n"
    "                       \"' failed with runtime error: '\" + e.what() + "
    "\"'\" +\n"
    "                       ansi_reset + \" (\" + "
    "std::to_string(duration_micro) +\n"
    "                       \"μs)\\n\";\n"
    "      return;\n"
    "    }\n"
    "    long duration_micro = sw.stop_micro();\n"
    "    std::cout << ansi_fg_green + \"SUCCESS [\" + suitname + \"]: \" + "
    "testname +\n"
    "                     ansi_reset + \" (\" + std::to_string(duration_micro) "
    "+\n"
    "                     \"μs)\\n\";\n"
    "  }\n"
    "\n"
    "  void assert(bool cond) {\n"
    "    if (!cond) {\n"
    "      throw TestCaseFailure(\"test on condition failed\");\n"
    "    }\n"
    "  }\n"
    "  void assert_str_eq(const std::string &a, const std::string &b) {\n"
    "    if (a != b) {\n"
    "      throw TestCaseFailure(\"'\" + a + \"'is not equal to expected '\" + "
    "b + \"'\");\n"
    "    }\n"
    "  }\n"
    "  void fail(const std::string &msg) { throw TestCaseFailure(msg); }\n"
    "  void success() {}\n"
    "  void assert_throws_with_message_contains(const std::function<void()> "
    "&fn,\n"
    "                                           const std::string &error_msg) "
    "{\n"
    "    try {\n"
    "      fn();\n"
    "    } catch (std::runtime_error e) {\n"
    "      if (std::string(e.what()).find(error_msg) == std::string::npos) {\n"
    "        this->fail(\"expected runtime_error message '\" + "
    "std::string(e.what()) +\n"
    "                   \"' to contain '\" + error_msg + \"'\");\n"
    "      }\n"
    "      return;\n"
    "    }\n"
    "    this->fail(\"expected a runtime_error\");\n"
    "  }\n"
    "  void assert_throws(const std::function<void()> &fn) {\n"
    "    try {\n"
    "      fn();\n"
    "    } catch (std::runtime_error e) {\n"
    "      this->success();\n"
    "      return;\n"
    "    }\n"
    "    this->fail(\"expected a runtime_error\");\n"
    "  };\n"
    "};\n"
    "#endif\n";

static std::string STOPWATCH_HEADER_FILE_CONTENT =
    "#ifndef _ASAP_STOPWATCH\n"
    "#define _ASAP_STOPWATCH\n"
    "\n"
    "#include <chrono>\n"
    "class StopWatch {\n"
    "private:\n"
    "  std::chrono::high_resolution_clock::time_point start_ts;\n"
    "\n"
    "public:\n"
    "  StopWatch() : start_ts(std::chrono::high_resolution_clock::now()) {}\n"
    "  void reset() { this->start_ts = "
    "std::chrono::high_resolution_clock::now(); }\n"
    "  long stop_ms() {\n"
    "    std::chrono::time_point stop = "
    "std::chrono::high_resolution_clock::now();\n"
    "    return std::chrono::duration_cast<std::chrono::milliseconds>(stop -\n"
    "                                                                 "
    "this->start_ts)\n"
    "        .count();\n"
    "  }\n"
    "  long stop_micro() {\n"
    "    std::chrono::time_point stop = "
    "std::chrono::high_resolution_clock::now();\n"
    "    return std::chrono::duration_cast<std::chrono::microseconds>(stop -\n"
    "                                                                 "
    "this->start_ts)\n"
    "        .count();\n"
    "  }\n"
    "};\n"
    "#endif\n";
