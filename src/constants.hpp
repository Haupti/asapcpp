#pragma once

#include <string>

static std::string MAIN_FILE_CONTENT =
    "#include <iostream>\n"
    "#include <vector>\n"
    "\n"
    "int main(int args, char ** argv) {\n"
    "    std::vector<std::string> arguments;\n"
    "    arguments.reserve(args);\n"
    "    for(int i = 0; i< args; i++){\n"
    "      arguments.push_back(std::string(argv[i]));\n"
    "    }\n"
    "    std::cout << \"Hello with arguments:\\n\";\n"
    "    for(const std::string &argument : arguments){\n"
    "      std::cout << \" - \" << argument << \"\\n\";\n"
    "    }\n"
    "    return 0;\n"
    "}\n";

static std::string TEST_EXAMPLE_FILE_CONTENT =
    "#include \"../lib/asap/t.hpp\"\n"
    "\n"
    "void test_example(T* t) {\n"
    "    t->assert(true);\n"
    "}\n"
    "\n"
    "int main() {\n"
    "    T t(\"ExampleSuite\");\n"
    "    t.test(\"SimpleAssert\", test_example);\n"
    "    return 0;\n"
    "}\n";

static std::string T_HEADER_FILE_CONTENT =
    ""
    "#ifndef _ASAP_T\n"
    "#define _ASAP_T\n"
    "\n"
    "#include \"stopwatch.hpp\"\n"
    "#include <functional>\n"
    "#include <iostream>\n"
    "#include <stdexcept>\n"
    "#include <string>\n"
    "\n"
    "class TestCaseFailure : public std::runtime_error {\n"
    "public:\n"
    "  TestCaseFailure(const std::string &message) : "
    "std::runtime_error(message) {}\n"
    "\n"
    "  const char *what() const noexcept override { return "
    "runtime_error::what(); }\n"
    "};\n"
    "\n"
    "class T {\n"
    "private:\n"
    "  const std::string ansi_fg_red = \"\x1b[31m\";\n"
    "  const std::string ansi_fg_green = \"\x1b[32m\";\n"
    "  const std::string ansi_reset = \"\x1b[0m\";\n"
    "  std::vector<std::string> failures_testnames;\n"
    "  std::vector<std::string> failures_messages;\n"
    "  std::vector<std::string> successes_testnames;\n"
    "  std::string suitname;\n"
    "\n"
    "public:\n"
    "  T(const std::string &suitname_param) {\n"
    "    failures_testnames = {};\n"
    "    failures_messages = {};\n"
    "    successes_testnames = {};\n"
    "    suitname = suitname_param;\n"
    "  };\n"
    "\n"
    "  void test(const std::string &testname,\n"
    "            const std::function<void(T *)> &testcase) {\n"
    "    StopWatch sw = StopWatch();\n"
    "    try {\n"
    "      testcase(this);\n"
    "    } catch (TestCaseFailure e) {\n"
    "      long duration_micro = sw.stop_micro();\n"
    "      std::cout << ansi_fg_red + \"FAILURE [\" + suitname + \"] of '\" + "
    "testname +\n"
    "                       \"': \" + e.what() + ansi_reset + \" (\" +\n"
    "                       std::to_string(duration_micro) + \"μs)\\n\";\n"
    "      return;\n"
    "    } catch (std::runtime_error e) {\n"
    "      long duration_micro = sw.stop_micro();\n"
    "      std::cout << ansi_fg_red + \"FAILURE [\" + suitname + \"] of '\" + "
    "testname +\n"
    "                       \"' failed with runtime error: '\" + e.what() + "
    "\"'\" +\n"
    "                       ansi_reset + \" (\" + "
    "std::to_string(duration_micro) +\n"
    "                       \"μs)\\n\";\n"
    "      return;\n"
    "    }\n"
    "    long duration_micro = sw.stop_micro();\n"
    "    std::cout << ansi_fg_green + \"SUCCESS [\" + suitname + \"]: \" + "
    "testname +\n"
    "                     ansi_reset + \" (\" + std::to_string(duration_micro) "
    "+\n"
    "                     \"μs)\\n\";\n"
    "  }\n"
    "\n"
    "  void assert(bool cond) {\n"
    "    if (!cond) {\n"
    "      throw TestCaseFailure(\"test on condition failed\");\n"
    "    }\n"
    "  }\n"
    "  void assert_str_eq(const std::string &a, const std::string &b) {\n"
    "    if (a != b) {\n"
    "      throw TestCaseFailure(\"'\" + a + \"'is not equal to expected '\" + "
    "b + \"'\");\n"
    "    }\n"
    "  }\n"
    "  void fail(const std::string &msg) { throw TestCaseFailure(msg); }\n"
    "  void success() {}\n"
    "  void assert_throws_with_message_contains(const std::function<void()> "
    "&fn,\n"
    "                                           const std::string &error_msg) "
    "{\n"
    "    try {\n"
    "      fn();\n"
    "    } catch (std::runtime_error e) {\n"
    "      if (std::string(e.what()).find(error_msg) == std::string::npos) {\n"
    "        this->fail(\"expected runtime_error message '\" + "
    "std::string(e.what()) +\n"
    "                   \"' to contain '\" + error_msg + \"'\");\n"
    "      }\n"
    "      return;\n"
    "    }\n"
    "    this->fail(\"expected a runtime_error\");\n"
    "  }\n"
    "  void assert_throws(const std::function<void()> &fn) {\n"
    "    try {\n"
    "      fn();\n"
    "    } catch (std::runtime_error e) {\n"
    "      this->success();\n"
    "      return;\n"
    "    }\n"
    "    this->fail(\"expected a runtime_error\");\n"
    "  };\n"
    "};\n"
    "#endif\n";

static std::string STOPWATCH_HEADER_FILE_CONTENT =
    "#ifndef _ASAP_STOPWATCH\n"
    "#define _ASAP_STOPWATCH\n"
    "\n"
    "#include <chrono>\n"
    "class StopWatch {\n"
    "private:\n"
    "  std::chrono::high_resolution_clock::time_point start_ts;\n"
    "\n"
    "public:\n"
    "  StopWatch() : start_ts(std::chrono::high_resolution_clock::now()) {}\n"
    "  void reset() { this->start_ts = "
    "std::chrono::high_resolution_clock::now(); }\n"
    "  long stop_ms() {\n"
    "    std::chrono::time_point stop = "
    "std::chrono::high_resolution_clock::now();\n"
    "    return std::chrono::duration_cast<std::chrono::milliseconds>(stop -\n"
    "                                                                 "
    "this->start_ts)\n"
    "        .count();\n"
    "  }\n"
    "  long stop_micro() {\n"
    "    std::chrono::time_point stop = "
    "std::chrono::high_resolution_clock::now();\n"
    "    return std::chrono::duration_cast<std::chrono::microseconds>(stop -\n"
    "                                                                 "
    "this->start_ts)\n"
    "        .count();\n"
    "  }\n"
    "};\n"
    "#endif\n";

static std::string UTIL_HEADER_FILE_CONTENT =
    "#ifndef __ASAP_UTIL\n"
    "#define __ASAP_UTIL\n"
    "\n"
    "#include <iostream>\n"
    "#include <vector>\n"

    "namespace ANSI {\n"
    "static std::string BLACK = \"\\x1b[30m\";\n"
    "static std::string RED = \"\\x1b[31m\";\n"
    "static std::string GREEN = \"\\x1b[32m\";\n"
    "static std::string YELLOW = \"\\x1b[33m\";\n"
    "static std::string BLUE = \"\\x1b[34m\";\n"
    "static std::string MAGENTA = \"\\x1b[35m\";\n"
    "static std::string CYAN = \"\\x1b[36m\";\n"
    "static std::string WHITE = \"\\x1b[37m\";\n"
    "\n"
    "static std::string BLACK_BG = \"\\x1b[40m\";\n"
    "static std::string RED_BG = \"\\x1b[41m\";\n"
    "static std::string GREEN_BG = \"\\x1b[42m\";\n"
    "static std::string YELLOW_BG = \"\\x1b[43m\";\n"
    "static std::string BLUE_BG = \"\\x1b[44m\";\n"
    "static std::string MAGENTA_BG = \"\\x1b[45m\";\n"
    "static std::string CYAN_BG = \"\\x1b[46m\";\n"
    "static std::string WHITE_BG = \"\\x1b[47m\";\n"
    "\n"
    "static std::string BRIGHT_BLACK = \"\\x1b[90m\";\n"
    "static std::string BRIGHT_RED = \"\\x1b[91m\";\n"
    "static std::string BRIGHT_GREEN = \"\\x1b[92m\";\n"
    "static std::string BRIGHT_YELLOW = \"\\x1b[93m\";\n"
    "static std::string BRIGHT_BLUE = \"\\x1b[94m\";\n"
    "static std::string BRIGHT_MAGENTA = \"\\x1b[95m\";\n"
    "static std::string BRIGHT_CYAN = \"\\x1b[96m\";\n"
    "static std::string BRIGHT_WHITE = \"\\x1b[97m\";\n"
    "\n"
    "static std::string BRIGHT_BLACK_BG = \"\\x1b[100m\";\n"
    "static std::string BRIGHT_RED_BG = \"\\x1b[101m\";\n"
    "static std::string BRIGHT_GREEN_BG = \"\\x1b[102m\";\n"
    "static std::string BRIGHT_YELLOW_BG = \"\\x1b[103m\";\n"
    "static std::string BRIGHT_BLUE_BG = \"\\x1b[104m\";\n"
    "static std::string BRIGHT_MAGENTA_BG = \"\\x1b[105m\";\n"
    "static std::string BRIGHT_CYAN_BG = \"\\x1b[106m\";\n"
    "static std::string BRIGHT_WHITE_BG = \"\\x1b[107m\";\n"
    "\n"
    "static std::string BRIGHT_GRAY = \"\\x1b[37m\";\n"
    "static std::string CR = \"\\r\";\n"
    "\n"
    "static std::string CURSOR_UP = \"\\x1b[A\";\n"
    "static std::string CURSOR_DOWN = \"\\x1b[B\";\n"
    "static std::string CURSOR_FORWARD = \"\\x1b[C\";\n"
    "static std::string CURSOR_BACK = \"\\x1b[D\";\n"
    "static std::string CURSOR_NEXTL = \"\\x1b[E\";\n"
    "static std::string CURSOR_PREVL = \"\\x1b[F\";\n"
    "\n"
    "static std::string ERASE_LINE = \"\\x1b[2K\";\n"
    "static std::string ERASE_SCREEN = \"\\x1b[2J\";\n"
    "\n"
    "static std::string BOLD = \"\\x1b[1m\";\n"
    "static std::string ITALIC = \"\\x1b[3m\";\n"
    "static std::string UNDERLINE = \"\\x1b[4m\";\n"
    "static std::string BLINK = \"\\x1b[5m\";\n"
    "\n"
    "static std::string RESET = \"\\x1b[0m\";\n"
    "}; // namespace ANSI\n"

    "// logging\n"
    "inline void println(const std::string &msg) { std::cout << msg << \"\\n\"; }\n"
    "\n"
    "inline void print(const std::string &msg) { std::cout << msg; }\n"
    "inline void warn(const std::string &msg) {\n"
    "  println(ANSI::BRIGHT_YELLOW + msg + ANSI::RESET);\n"
    "}\n"
    "inline void info(const std::string &msg) {\n"
    "  println(ANSI::BRIGHT_GRAY + msg + ANSI::RESET);\n"
    "}\n"
    "\n"
    "// error and user error\n"
    "inline void fail [[noreturn]] (const std::string &msg) {\n"
    "  println(ANSI::RED + msg + ANSI::RESET);\n"
    "  exit(1);\n"
    "}\n"
    "#define panic(msg)                                                        "
    "     \\\n"
    "  throw std::runtime_error(\"ERROR in \" + std::string(__FILE__) + \"/\" "
    "+         \\\n"
    "                           std::to_string(__LINE__) + \": \" + msg + "
    "\"\\n\");\n"

    "inline void overwrite_println(const std::string &msg) {\n"
    "  println(ANSI::CURSOR_UP + ANSI::ERASE_LINE + ANSI::CR + "
    "ANSI::BRIGHT_GRAY +\n"
    "          msg + ANSI::RESET);\n"
    "}\n"
    "// file utilities\n"
    "void write_file(const std::string &filepath, const std::string "
    "&content);\n"
    "std::string read_file(const std::string &filepath);\n"
    "\n"
    "// string utilities\n"
    "bool ends_with(const std::string &str, const std::string &suffix);\n"
    "bool starts_with(const std::string &str, const std::string &prefix);\n"
    "std::string join(const std::vector<std::string> &list, std::string "
    "delim);\n"
    "\n"
    "#endif\n";

static std::string UTIL_IMPL_FILE_CONTENT =
    "#include \"util.hpp\"\n"
    "#include <cstdint>\n"
    "#include <filesystem>\n"
    "#include <fstream>\n"
    "#include <string>\n"
    "\n"
    "void write_file(const std::string &filepath, const std::string &content) "
    "{\n"
    "  std::ofstream f(filepath);\n"
    "  if (!f.good()) {\n"
    "    panic(\"failed to write file '\" + filepath + \"'\");\n"
    "  }\n"
    "  f << content;\n"
    "}\n"
    "std::string read_file(const std::string &filepath) {\n"
    "  std::ifstream f(filepath);\n"
    "  if (!f.good()) {\n"
    "    panic(\"failed to read file '\" + filepath + \"'\");\n"
    "  }\n"
    "  uint64_t size = std::filesystem::file_size(filepath);\n"
    "  std::string buffer(size, '\\0');\n"
    "  f.read(buffer.data(), size);\n"
    "  return buffer;\n"
    "}\n"
    "\n"
    "bool ends_with(const std::string &str, const std::string &suffix) {\n"
    "  if (str.size() < suffix.size()) {\n"
    "    return false;\n"
    "  }\n"
    "  return str.compare(str.size() - suffix.size(), suffix.size(), suffix) "
    "== 0;\n"
    "}\n"
    "\n"
    "bool starts_with(const std::string &str, const std::string &prefix) {\n"
    "  if (str.size() < prefix.size()) {\n"
    "    return false;\n"
    "  }\n"
    "  return str.compare(0, prefix.size(), prefix) == 0;\n"
    "}\n"
    "\n"
    "std::string join(const std::vector<std::string> &list, std::string delim) "
    "{\n"
    "  std::string result;\n"
    "  for (size_t i = 0; i < list.size(); i++) {\n"
    "    result += list[i];\n"
    "    if (i != (list.size() - 1)) {\n"
    "      result += delim;\n"
    "    }\n"
    "  }\n"
    "  return result;\n"
    "}\n";
